JS 的“单线程模型”，核心就一句话：
同一时间，JavaScript 只在一个主线程里执行一段代码，不会同时跑两段 JS。
但它之所以还能“异步”“高并发”，靠的是：调用栈(Call Stack) + Web APIs/Node APIs + 事件循环(Event Loop) + 各种任务队列(Task Queue)。下面按层次讲。
1. 为什么是单线程？
JS 最初是给浏览器写交互的：
一个线程同时负责：操作 DOM、处理用户事件、执行 JS。
如果是多线程同时改 DOM，很容易出现 DOM 状态冲突（比如两个线程同时删同一个节点）。
所以浏览器规范里，JS 执行是单线程：
不会出现“两个 JS 线程同时改一个变量”的情况。
简化了开发——不用自己处理锁、互斥之类的并发控制。
注意：单线程的是 JS 执行主线程，不是说浏览器或 Node 只用一个线程。
2. 同步代码：调用栈（Call Stack）
同步代码执行时，JS 引擎内部有一个 调用栈：
js
function a() {
  b();
}

function b() {
  console.log('b');
}

a();
执行流程：
a() 入栈，开始执行 a 函数。
在 a 内部调用 b()，b 入栈。
执行完 b，b 出栈。
接着执行完 a，a 出栈。
栈空了，本轮同步任务结束。
一次只能处理栈顶的那个函数，这就是“单线程”的直接体现。
3. 异步的本质：主线程 + 其他线程/能力
JS 本身只有一个主线程跑 JS，但浏览器/Node 底层有很多“助手”：
浏览器里的 Web APIs：
setTimeout、DOM 事件、网络请求（XHR/fetch）、定时器、Web Worker 等。
Node 里的底层线程池、I/O 线程等。
流程可以理解为：
js
console.log('start');

setTimeout(() => {
  console.log('timer');
}, 1000);

console.log('end');
执行到 setTimeout：
JS 引擎把“计时”这件事交给浏览器定时器模块去做；
自己继续往下执行，不会在这儿卡 1 秒。
同步代码执行完，调用栈空了。
定时器时间到了，浏览器把回调函数放进“任务队列”。
事件循环发现“栈空 + 队列有任务”，就把回调取出来，压入栈，执行它。
因此：异步是环境帮你做耗时工作，完成后再把回调交回主线程执行。
4. 事件循环（Event Loop）和任务队列
可以把事件循环理解为一个无限的 while(true)：
text
while (true) {
  如果调用栈为空：
    从任务队列中取一个任务放进栈执行
}
任务队列（Task Queue）里放着待执行的回调，比如：
setTimeout / setInterval 的回调
网络请求完成的回调
用户点击事件的回调
Node 的一些回调等
5. 宏任务 & 微任务（浏览器/Node 都有）
为了更精细地安排顺序，通常会区分：
宏任务（Macro Task）
示例：setTimeout、setInterval、I/O 回调、script 整体代码块
微任务（Micro Task）
示例：Promise.then/catch/finally、queueMicrotask、Node 的 process.nextTick（Node 环境）
一个经典执行顺序规则（简化版）：
先执行一个宏任务（比如整段 <script> 代码）。
本次宏任务中的同步代码都跑完，调用栈空了。
立即清空“微任务队列”（把里面的微任务一个个执行完）。
如果需要渲染，则进行一次页面渲染。
再去取下一个宏任务执行，重复 1~4。
例子：
js
console.log('start');

setTimeout(() => {
  console.log('timeout');
}, 0);

Promise.resolve().then(() => {
  console.log('microtask');
});

console.log('end');
输出顺序：
start
end
microtask // 微任务
timeout // 宏任务
理由：同步 → 微任务 → 下一个宏任务。
6. 单线程下的“并发”感觉从何而来？
JS 单线程，所以：
同一时刻只执行一个 JS 任务。
但：多个异步操作可以“同时在路上”：
多个网络请求由浏览器的网络模块并发处理；
文件读写、定时器、数据库等由系统或线程池并发处理。
JS 主线程只是：
把任务发出去；
等结果回来时再执行回调。
所以我们感受到的是“并发处理很多事情”，但实际 JS 依然是单线程“排队执行回调”。
7. 与多线程语言的对比（简单直觉）
在 Java/C++ 的多线程里：
可能有多个线程同时执行用户代码, 需要锁、互斥、原子操作来防止数据竞争。
例如两个线程同时改同一个变量。
JS 的设计是：
一个主线程执行用户代码，避免了数据竞争。
并发工作交给引擎/浏览器底层，它们再把结果一条条送回来。
8. 小结（记住这几点就够用）
JS 是单线程执行的：同一时刻只有一个 JS 调用栈在跑。
异步由宿主环境（浏览器/Node）提供：定时器、网络、I/O 等都在别的线程或模块中运行。
事件循环负责调度：
栈空时，从任务队列里取出下一个任务执行；
区分宏任务和微任务，先清微任务再执行下一个宏任务。
这种模型让 JS：
简化了并发编程（不用自己写锁）；
又能高效处理大量 I/O 异步任务。
如果你愿意，我可以下一步画一张简单的“事件循环流程图”（用文字+简单图示），或者结合你项目里的某段异步代码（比如 promise/async.html 那几个文件）具体分析执行顺序。