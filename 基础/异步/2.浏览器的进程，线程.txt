1.浏览器有什么进程，进程下有什么线程？
2.打开一个新的tab页面会怎么样
3.沙箱隔离什么数据





1. 浏览器有什么「进程」，每个进程下又有什么「线程」？
1）常见的几个浏览器进程
现代浏览器基本都是「多进程架构」（Chrome、Edge、新版的 QQ 浏览器等），大致会有这些进程：
浏览器进程（Browser Process）
整个浏览器的「大管家」。
主要负责：
地址栏、书签栏、前进/后退等 UI
管理各个 Tab 的生命周期（新建、关闭）
进程管理（创建/销毁渲染进程）
部分硬盘访问（下载文件、保存 cookie 等）
渲染进程（Renderer Process）
每个 Tab 页一般对应一个渲染进程（有时同站点复用，但可以先认为一 Tab 一个）。
负责：
解析 HTML/CSS
布局、绘制页面
执行 JS
处理页面上的事件（点击、输入等）
网络进程（Network Process）（早期是浏览器进程中的网络线程）
负责所有网络请求：
发起 HTTP/HTTPS 请求
管理 TCP / TLS 连接
处理缓存等
GPU 进程（GPU Process）
负责使用显卡进行加速绘制：
CSS 动画、复杂渲染效果
Canvas / WebGL 等
插件进程（Plugin Process）（现在很少，比如早期 Flash）
让插件在单独进程里跑，崩溃不影响整个浏览器。
可以简单记：浏览器进程 管理全局，渲染进程 负责每个页面，网络进程 管理请求，GPU 进程 负责画图。
2）以「渲染进程」为例，它下面有哪些线程？
一个渲染进程内部又会开很多线程，常见的：
主线程（UI / JS / Rendering 主线程）
我们写的 JS，绝大部分都在这里执行。
负责：
执行 JS 代码
解析 HTML / CSS
计算布局、样式
DOM 操作、页面重排重绘
处理大部分事件（click、input 等）
因为这些事情都在一个线程里，所以浏览器主线程是「单线程执行 JS」——这是你学「单线程模型」的基础。
事件（消息）循环线程 / 任务队列
主线程内部配合事件循环机制（macroTask / microTask 队列）。
setTimeout、promise.then 这些任务，就是排队到不同队列，然后由主线程一个一个取出来执行。
合成线程（Compositor Thread）
把页面分成多层（图层），负责合成、滚动、动画。
某些简单的 CSS 动画（比如 transform、opacity）可以在合成线程完成，减少主线程压力，使动画更流畅。
光栅化线程（Raster Thread）
把矢量的绘制指令变成位图，交给 GPU 绘制。
简单理解：把页面「真正画成像素」。
IO 线程（网络 / 文件 / 管道 IO）
用来和其他进程通信，接收网络进程的资源数据等。
Web Worker 线程
当页面中使用 new Worker(...) 时，会在渲染进程里开新的 worker 线程。
JS 工作线程，可执行 JS，但不能直接操作 DOM，只能通过 postMessage 与主线程通讯，用来做计算密集型任务，不堵 UI。
总的结构可以记成：一个渲染进程里，有一个主线程（跑 JS + 渲染），再加上合成线程、IO 线程、若干工作线程等。
2. 打开一个新的 Tab 页面会怎么样？
说的是：你在浏览器里按 Ctrl + T 或点「新建标签页」时，底层大概发生什么。
1）进程级别的变化
典型浏览器（Chrome）中的逻辑：
浏览器进程接收到「新建 Tab」指令
用户点击「+」，浏览器进程负责管理 UI，自然会先创建一个新的 Tab UI。
此时页面内容可能是一个「新标签页」的默认页面（比如常用网站）。
为新 Tab 分配渲染进程
一般情况：为新 Tab 创建一个新的渲染进程。
但现代浏览器会有优化：
同站点 / 同一域名的页面可能复用已有渲染进程（Site/Process 模型比较复杂，你现在只需知道：大概率是新进程，但也可能复用）。
不管怎样，对你来说：新的 Tab 通常是「新的页面上下文」，不会和旧 Tab 的 JS 共用同一个运行环境。
新页面加载
渲染进程收到要加载的 URL：
发起网络请求（通过网络进程）
下载 HTML、CSS、JS 等
解析、构建 DOM 树、CSSOM 树、渲染树、布局、绘制
执行对应页面的 JS 代码
2）与旧 Tab 的关系
不同 Tab 一般在不同渲染进程中：
一个页面崩溃（渲染进程挂掉）不会直接导致整个浏览器挂掉，只是这个 Tab 变「崩溃啦」。
内存、JS 运行环境互相隔离：
A 标签页里声明的变量、运行的 JS，不会直接影响 B 标签页。
但它们可以通过某些机制间接通信，比如：
localStorage、IndexedDB （同源情况下）
BroadcastChannel
postMessage + window.open 得到的引用
可以简化理解：新开一个 Tab，本质上是新开一个（或复用一个）渲染进程，里面有自己的主线程、自己的 JS 环境。
3. 沙箱（sandbox）隔离了哪些数据 / 权限？
「沙箱」这个词的核心含义：
把不太可信或可能出错的代码，关在一个受限制的空间里运行，即使它出错或被攻击，也尽量不要影响到系统其它部分。
在浏览器里主要包括两层含义：
1）进程级的沙箱：保护操作系统 & 其他应用
渲染进程通常都是「低权限沙箱进程」：
不能随便访问本地文件系统（不能到处读你的 C 盘、Documents）
不能直接访问摄像头、麦克风、USB 等硬件（需要用户授权，由浏览器进程控制）
不能直接跳出浏览器窗口控制系统
它如果中招（比如你访问了恶意网站），攻击者拿到的是一个被限制住的渲染进程的权限，而不是整个系统的权限。
这一层是操作系统级别的隔离：渲染进程被当作“危险分子”，给它圈一个活动范围。
2）站点级 / 同源级的沙箱：不同网站之间互相隔离
浏览器还会确保：不同站点之间的敏感数据互相隔离，互相看不到。
主要包括：
Cookie、localStorage、sessionStorage、IndexedDB 等按「同源策略」隔离
不同域名 / 协议 / 端口，不能直接访问对方的本地存储。
比如：https://a.com 的 JS 读不到 https://b.com 的 localStorage。
DOM 和 JS 作用域隔离
A 页面的脚本不能随便操作 B 页面的 DOM（除非有特定关系，比如 iframe 且同源）。
内存隔离
不同渲染进程有不同的内存空间，即使都是你浏览器里的两个 Tab，也不能直接看到对方的变量、对象。
Site Isolation（站点隔离）
Chrome 在一些设置下，会为不同站点分别开渲染进程，以防某个站点通过漏洞越界读取别的站点的内容。
简单说：
对操作系统：浏览器把每个页面关在进程沙箱里，不让它乱碰你的系统数据。
对其他网站 / Tab：再加一层隔离，不让一个网站随便看到另一个网站的隐私数据（cookie、本地存储、DOM 等）。
小结（帮你记忆）
浏览器的进程和线程
进程：浏览器进程、多个渲染进程、网络进程、GPU 进程、插件进程等。
渲染进程里：主线程（JS/渲染）、合成线程、IO 线程、Web Worker 线程等。
新开一个 Tab 会怎样
浏览器进程创建新的 Tab UI。
为新 Tab 创建或复用一个渲染进程。
渲染进程加载并渲染新页面，拥有独立的 JS 环境。
沙箱隔离什么
在操作系统层面：限制渲染进程的权限，保护本地文件、硬件、安全。
在网站之间：按同源策略隔离 cookie / localStorage / DOM / 内存，防止不同网站窃取彼此数据。
如果你愿意，我可以帮你把这一份内容压缩成更短的背诵版，或者配一张「浏览器多进程架构」的简易示意图（文字或 mermaid 图都行）。
说网络请求是宏任务，那么fetch他是返回promise啊
说网络请求是宏任务，那么fetch他是返回promise啊
深度思考 · 3s
你这个疑惑非常关键，其实是两件事混在一起了：
「网络请求是宏任务」这句话，说的是事件来源 / 任务来源
fetch 返回的是 Promise 对象，说的是JS 里的异步编程模型
把它们拆开看就不矛盾了。
1. 先说：网络请求到底是不是“宏任务”？
更严谨一点说：
网络请求本身不是“任务”，它是在浏览器的 Web APIs / 网络线程 里跑的 I/O。
真正进入事件循环队列的，是 “网络请求完成后要执行的回调任务”。
对 XHR 来说，通常说的是：
请求完成后，触发 onload/onreadystatechange 那个回调，是作为一个 宏任务 放到任务队列里的。
对 fetch 来说，底层也类似：
网络层拿到结果后，会安排一个任务，去更新 fetch 对应的 Promise 状态（resolve/reject）。
这个“更新 Promise 状态”的动作在规范里是通过 task + microtask 组合实现的，但对我们来说，可以简化成：
网络线程 → 通知主线程：请求好了（这里相当于一个宏任务来源）
主线程 → 在一个合适的任务中，把 Promise 标记为已完成，然后触发 Promise 的微任务。
2. 再说：那 fetch 返回 Promise 是怎么回事？
看执行流程：
js
console.log('1');
fetch('/api').then(() => {
  console.log('2 then');
});
console.log('3');
执行顺序是：
当前宏任务：执行 JS 脚本
执行 console.log('1')
调用 fetch('/api')
立即发起网络请求（交给浏览器的网络层去做）
立刻返回一个「pending 状态的 Promise」 给 JS
注册 .then(...)，实际上是把回调存在 Promise 里
执行 console.log('3')
当前宏任务结束 → 执行当前产生的所有 microtask（如果有）
网络层在后台慢慢请求
这段时间 JS 主线程可以干别的事情。
请求完成
浏览器网络层把结果传给 JS 这边，安排一个任务：
类似 “处理 fetch 响应”的任务（你可以把它理解为由网络 I/O 产生的“宏任务来源”）。
在这个任务里，浏览器代码会：
把之前那个 Promise 从 pending → fulfilled/rejected
这样一来，Promise 的 then 回调就被放进 microtask 队列。
事件循环继续
取出这个任务执行（宏任务）
它把 Promise 状态改好之后，事件循环会按规则去跑 microtask 队列
→ 执行你的 .then(...) 回调
所以你看到的效果是：
fetch 立即返回 Promise（同步）
但这个 Promise 的 完成时机 是由“网络 I/O + 事件循环中的任务”来决定的
真正执行你 .then(...) 回调时，是作为 微任务 来跑的
3. 用一句话串起来：
「网络请求是宏任务」——指的是：网络 I/O 完成会产生一个新的任务（宏任务来源）。
fetch 返回 Promise——指的是：用 Promise 这套机制来包装这个异步结果，最终回调（then/catch/finally）是以「微任务」的形式执行的。
所以二者并不冲突，只是不同层次的概念：
底层：网络线程 + 宏任务（把结果送回 JS 世界）
JS 层：Promise + 微任务（执行 then 回调）
如果你愿意，我可以画一个简单时间线图，把 setTimeout、fetch、Promise.then 在事件循环里的顺序对比一下，更直观