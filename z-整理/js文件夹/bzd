function getTime(call, delay) {
let timer = null;
function fun() {
timer = setTimeout(() => {
call();
clearTimeout(timer);
fun();
}, delay);
}
   fun();
        return timer;
    }这个结构无法实现停止吧



你说得对。在原有的结构中，getTime 返回的是第一次 setTimeout 的 ID。当定时器触发并递归调用 fun() 时，会生成一个新的 setTimeout ID，但外部变量 timer 拿到的仍然是旧的 ID。因此，外部调用 clearTimeout(timer) 只能停止已经执行过的第一个定时器（实际上已经没用了），而无法停止后续新生成的定时器。

我已经修复了这个问题，通过返回一个包含 id 属性的对象，并在递归时不断更新这个 id，这样外部就能通过引用获取到最新的定时器 ID 并成功停止它。

修改后的代码如下：

Edited
定时器.html
主要改进点：
返回对象引用：返回一个对象 { id: ... } 而不是原始的 ID 数字。
动态更新 ID：在 fun 函数内部，每次 setTimeout 都会更新 timer.id，保证外部持有的引用始终指向最新的定时
器任务。
3. 移除冗余代码：去掉了回调函数内部无意义的 clearTimeout(timer)。




只要是return或者传入基本类型数据，都是他们的拷贝吗

是的，你的理解非常准确。

在 JavaScript 中：

基本类型（Primitive Types）：
包括 Number、String、Boolean、null、undefined、Symbol。

赋值、传参、Return：都是按值传递（Copy）。
也就是把“值”复制一份给对方。修改新的变量不会影响原来的变量。
你的例子中：return timer 返回的是那一瞬间的数字（比如 1）。即使函数内部的 timer 变量后来变成了 2、3，外面拿到的那个 1 永远不会变。
引用类型（Reference Types）：
包括 Object、Array、Function。

赋值、传参、Return：都是按引用传递（Address）。
也就是把“内存地址”复制一份给对方。大家指向同一个房间，谁改了房间里的东西，大家都能看到。
修复方案中：我们返回了一个对象 { id: ... }。外部拿到的是这个对象的地址。函数内部修改 obj.id，外部通过同一个地址去读 obj.id，就能读到最新的值。
针对你的代码的两种常见解法：
因为基本类型无法“实时同步”，所以通常用以下两种方式来解决这种“需要停止递归定时器”的问题：

方法一：利用引用类型（闭包 + 对象）
这就是我刚才帮你改的方法，返回一个对象，让内外共享同一个对象引用。

function getTime(call, delay) {
    let ref = { id: null }; // 创建一个对象
    function fun() {
        // 修改对象内部的属性，外部也能看到变化
        ref.id = setTimeout(() => {
            call();
            fun();
        }, delay);
    }
    fun();
    return ref; // 返回对象引用
}

// 使用
const timerObj = getTime(..., 1000);
clearTimeout(timerObj.id); // 永远能取到最新的 id

方法二：利用闭包（返回停止函数）
不返回 ID，而是直接返回一个“停止函数”。这是更高级、更封装的做法。



function getTime(call, delay) {
    let timer = null;
    function fun() {
        timer = setTimeout(() => {
            call();
            fun();
        }, delay);
    }
    fun();
    
    // 返回一个专门用来清除当前 timer 的函数
    return functionfunction getTime(call, delay) {
    let timer = null;
    function fun() {
        timer = setTimeout(() => {
            call();
            fun();
        }, delay);
    }
    fun();
    
    // 返回一个专门用来清除当前 timer 的函数
    return function

    stop() {
clearTimeout(timer);
};
}

// 使用
const stopTimer = getTime(..., 1000);
stopTimer(); // 直接调用返回的函数来停止

