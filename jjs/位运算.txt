位运算是直接对二进制位（bit） 进行操作的底层运算，由 CPU 原生支持，无额外开销、执行速度极快，是性能敏感场景（如框架源码、算法、底层开发）的常用优化手段。本文将从核心位运算规则、实用基础技巧、经典算法实例三方面详细讲解，兼顾原理与实战，同时结合编程场景说明其优势。
一、基础前置知识
位运算的操作对象是整数的二进制补码（计算机底层存储整数的标准形式），所有运算均按二进制位逐位执行，无需类型转换或额外计算，这是其性能优势的核心原因。本文所有示例均基于32 位有符号整数（前端 / 常规开发主流场景），二进制展示会简化为关键位（高位 0 可省略）。
二、6 种核心位运算：规则 + 示例 + 用途
编程中最常用的位运算共 6 种，包含基础位运算（按位与、或、异或、取反）和位移运算（左移、右移），以下是每种运算的核心规则、十进制 / 二进制示例、典型用途，附直观计算过程：
1. 按位与（&）：全 1 则 1，有 0 则 0
核心规则：两个数的二进制对应位，同时为 1 结果才为 1，否则为 0；
核心用途：判断特定位是否为 1、保留指定位、清零无关位；
示例：9 & 5（9=1001，5=0101）
plaintext
1001  （9的二进制）
&0101  （5的二进制）
------
0001  （结果1，十进制1）
典型场景：判断数字奇偶（n & 1，结果 1 为奇数，0 为偶数）、校验状态标记（如 Vue3 PatchFlags 的状态判断）。
2. 按位或（|）：有 1 则 1，全 0 则 0
核心规则：两个数的二进制对应位，只要有一个为 1 结果就为 1，全 0 才为 0；
核心用途：组合多个状态标记、将指定位设为 1；
示例：9 | 5（9=1001，5=0101）
plaintext
1001  （9的二进制）
|0101  （5的二进制）
------
1101  （结果13，十进制13）
典型场景：多状态叠加（如 Vue3 中组合多个 PatchFlags 标记）、快速取整（正数n | 0）。
3. 按位异或（^）：不同则 1，相同则 0
核心规则：两个数的二进制对应位，值不同结果为 1，值相同结果为 0；
核心特性：
① 自反性：a ^ a = 0（一个数异或自身，所有位归 0）；
② 恒等性：a ^ 0 = a（一个数异或 0，保持原数不变）；
③ 交换律 / 结合律：a ^ b = b ^ a、(a ^ b) ^ c = a ^ (b ^ c)；
核心用途：交换两个数（无需临时变量）、翻转指定位、找唯一数（其他数出现偶数次）；
示例：9 ^ 5（9=1001，5=0101）
plaintext
1001  （9的二进制）
^0101  （5的二进制）
------
1100  （结果12，十进制12）
4. 按位取反（~）：逐位取反，1 变 0，0 变 1
核心规则：对一个数的所有二进制位逐位取反（包括符号位），是单目运算（仅一个操作数）；
关键注意：32 位有符号整数中，取反后需遵循补码规则，最终结果满足 ~n = -(n+1)（快速记忆公式）；
核心用途：快速取反、结合&/|实现复杂位操作、简化条件判断（如~index判断是否为 - 1）；
示例：~9（9 的 32 位二进制为0000 0000 0000 0000 0000 0000 0000 1001）
plaintext
原数：0000 0000 0000 0000 0000 0000 0000 1001  （9）
取反：1111 1111 1111 1111 1111 1111 1111 0110  （补码形式）
转换为十进制：-10（符合~n = -(n+1)，~9=-(9+1)=-10）
典型场景：判断数组索引是否存在（if (~arr.indexOf(val))，indexOf 返回 - 1 时，~-1=0，条件为 false）。
5. 左移运算（<<）：左移 n 位，右侧补 0
核心规则：将数的二进制位整体向左移动 n 位，左侧超出 32 位的部分直接舍弃，右侧空缺位补 0；
数值等价：无符号数 / 正数中，a << n = a * 2ⁿ（左移 n 位等价于乘以 2 的 n 次方），运算速度远快于乘法；
核心用途：快速生成 2 的幂次、快速乘法（2 的幂次倍）、设置特定位为 1；
示例：9 << 2（9=1001，左移 2 位）
plaintext
原数：1001  （9）
左移2位：100100  （右侧补2个0）
结果：36（9*2²=36，符合等价规则）
典型场景：Vue3 PatchFlags 中生成独立状态标记（1<<1、1<<2等）、高效数值放大。
6. 右移运算：分为「有符号右移（>>）」和「无符号右移（>>>）」
（1）有符号右移（>>）：右移 n 位，左侧补符号位
核心规则：将数的二进制位整体向右移动 n 位，右侧超出部分舍弃，左侧空缺位补原数的符号位（正数补 0，负数补 1）；
数值等价：正数中，a >> n = Math.floor(a / 2ⁿ)（右移 n 位等价于除以 2 的 n 次方并向下取整），速度快于除法；
核心用途：快速除法（2 的幂次倍）、保留符号位的位操作；
示例：9 >> 2（正数，9=1001）、-9 >> 2（负数，补码为1111...1111 0111）
plaintext
9 >> 2：1001 → 右移2位 → 0010 → 结果2（9/4=2.25，向下取整为2，符合等价规则）
-9 >> 2：补码右移2位，左侧补1 → 结果-3（保持负数符号）
（2）无符号右移（>>>）：右移 n 位，左侧统一补 0
核心规则：将数的二进制位整体向右移动 n 位，右侧超出部分舍弃，左侧无论正负，统一补 0；
关键注意：运算结果始终为非负数（因为最高位补 0），负数执行此运算会转换为大的正数（基于 32 位补码）；
核心用途：无符号数的位操作、处理二进制补码、正数的快速除法；
示例：9 >>> 2 = 2（和有符号右移结果一致），-9 >>> 2 = 1073741821（负数转换为非负数）。
三、位运算实用基础技巧（高频场景）
基于上述核心运算，衍生出一系列开发中常用的高效小技巧，替代传统运算 / 逻辑，大幅提升性能，且代码更简洁，以下是高频实用技巧，附实现代码和说明：
1. 快速判断奇偶性（替代n % 2）
原理：二进制中，最低位为 1 的数是奇数，为 0 的数是偶数，通过n & 1判断最低位；
实现：n & 1 === 1 → 奇数，n & 1 === 0 → 偶数；
示例：
javascript
运行
console.log(7 & 1); // 1 → 奇数
console.log(8 & 1); // 0 → 偶数
优势：位运算&比取模%快数倍，无计算开销。
2. 无需临时变量交换两个数（替代let temp = a; a = b; b = temp）
原理：利用异或的自反性（a^a=0）和恒等性（a^0=a），三步完成交换；
实现（仅适用于数值类型）：
javascript
运行
let a = 5, b = 9;
a = a ^ b; // a = 5^9 = 12
b = a ^ b; // b = 12^9 = 5（原a的值）
a = a ^ b; // a = 12^5 = 9（原b的值）
console.log(a, b); // 9 5 → 交换完成
优势：无需额外内存（临时变量），运算效率极高。
3. 快速取整（替代Math.floor()/parseInt()）
原理：位运算会自动舍弃小数部分，仅保留整数位；
实现：
正数：n | 0、n ^ 0、n >> 0（任意一种均可）；
负数：推荐Math.floor()（位运算结果与预期可能不一致，如-2.3 | 0 = -2，Math.floor(-2.3) = -3）；
示例：
javascript
运行
console.log(3.9 | 0); // 3
console.log(6.1 ^ 0); // 6
console.log(8.9 >> 0); // 8
优势：比 Math 系列方法快，代码更简洁。
4. 快速判断一个数是否为 2 的幂次
原理：2 的幂次的二进制仅有 1 个 1（如 2=10、4=100、8=1000），其减 1 后二进制所有低位全为 1（如 1=01、3=001、7=0111），两者按位与结果必为 0；
实现：(n > 0) && (n & (n - 1)) === 0（需排除 n=0，0 不是 2 的幂次）；
示例：
javascript
运行
console.log((8 > 0) && (8 & 7) === 0); // true（8是2的幂次）
console.log((6 > 0) && (6 & 5) === 0); // false（6不是2的幂次）
5. 快速计算两数的平均值（替代(a + b) / 2）
原理：右移 1 位等价于除以 2 并向下取整，结合按位与避免加法溢出；
实现：(a + b) >> 1 或 a + ((b - a) >> 1)（后者更安全，避免 a+b 超出数值范围）；
示例：
javascript
运行
console.log((5 + 9) >> 1); // 7（(5+9)/2=7）
console.log((3 + 8) >> 1); // 5（(3+8)/2=5.5，向下取整为5）
6. 快速将数字置 0（替代n = 0）
原理：利用异或自反性，n ^ n = 0；
实现：n ^= n；
示例：
javascript
运行
let n = 100;
n ^= n;
console.log(n); // 0
四、位运算经典算法实例（面试 / 实战高频）
位运算在算法题中应用广泛，尤其在数组、哈希、位状态管理类题目中，能实现时间 O (n)、空间 O (1) 的最优解，以下是 3 道经典高频算法题，附解题思路、位运算实现代码、核心原理，覆盖面试常考场景：
实例 1：只出现一次的数字（LeetCode 136）
题目描述
给定一个非空整数数组，除了某个元素只出现一次外，其余每个元素均出现两次，找出这个只出现一次的元素，要求：时间复杂度 O (n)，空间复杂度 O (1)。
解题思路
利用异或的三大特性：
相同数异或结果为 0（a^a=0），其余出现两次的数会相互抵消为 0；
0 异或任意数结果为原数（0^a=a），最终剩余的就是只出现一次的数；
异或满足交换律 / 结合律，遍历顺序不影响结果。
位运算实现代码（JavaScript）
javascript
运行
function singleNumber(nums) {
  let res = 0;
  for (const num of nums) {
    res ^= num; // 遍历异或所有数，抵消重复数
  }
  return res;
}

// 测试
console.log(singleNumber([2,2,1])); // 1
console.log(singleNumber([4,1,2,1,2])); // 4
核心优势
无需额外哈希表存储次数，空间复杂度从 O (n) 降至 O (1)，遍历一次即可，时间最优。
实例 2：找出数组中缺失的数字（LeetCode 268）
题目描述
给定一个包含0,1,2,...,n中n个数的数组，找出其中缺失的那个数，要求：空间复杂度 O (1)。
解题思路
组合异或的恒等性和自反性：
先遍历0~n的所有数，异或得到基础值；
再遍历数组中的所有数，与基础值异或；
最终结果为缺失的数（因为数组中存在的数会被异或两次抵消为 0，仅缺失的数被异或一次）。
简化实现：遍历一次数组，将索引i和元素nums[i]依次异或，最终再异或n（等价于遍历 0~n）。
位运算实现代码（JavaScript）
javascript
运行
function missingNumber(nums) {
  let res = 0;
  const n = nums.length;
  for (let i = 0; i < n; i++) {
    res ^= i ^ nums[i]; // 索引和元素依次异或
  }
  return res ^ n; // 最终异或n，覆盖0~n的所有数
}

// 测试
console.log(missingNumber([3,0,1])); // 2
console.log(missingNumber([0,1])); // 2
console.log(missingNumber([9,6,4,2,3,5,7,0,1])); // 8
实例 3：位状态压缩（多布尔状态管理）
场景描述
开发中常需要管理多个布尔状态（如权限：查看 = 1、编辑 = 2、删除 = 4、分享 = 8），传统方式用数组 / 对象存储（如{view: true, edit: false}），内存占用高且判断繁琐，可用位运算状态压缩，用一个整数存储所有布尔状态。
解题思路
为每个状态分配唯一的 2 的幂次标记（二进制仅 1 位为 1，避免冲突）；
用按位或（|） 组合状态（开启权限）；
用按位与（&） 判断状态（检查是否拥有某权限）；
用按位异或（^） 切换状态（开启 / 关闭某权限，若已开启则关闭，未开启则开启）。
位运算实现代码（JavaScript）
javascript
运行
// 1. 定义权限标记（2的幂次，唯一二进制位）
const Permission = {
  VIEW: 1,    // 0001 查看
  EDIT: 2,    // 0010 编辑
  DELETE: 4,  // 0100 删除
  SHARE: 8    // 1000 分享
};

// 2. 组合状态：给用户分配「查看+编辑+分享」权限
let userPerm = Permission.VIEW | Permission.EDIT | Permission.SHARE;
console.log(userPerm); // 11 → 二进制1011，代表拥有三个权限

// 3. 判断状态：检查用户是否拥有某权限
const hasDelete = (userPerm & Permission.DELETE) !== 0;
const hasEdit = (userPerm & Permission.EDIT) !== 0;
console.log(hasDelete); // false（无删除权限）
console.log(hasEdit);   // true（有编辑权限）

// 4. 切换状态：给用户关闭编辑权限，开启删除权限
userPerm ^= Permission.EDIT; // 关闭编辑：1011 ^ 0010 = 1001
userPerm ^= Permission.DELETE; // 开启删除：1001 ^ 0100 = 1101
console.log(userPerm); // 13 → 二进制1101，代表「查看+删除+分享」

// 5. 检查最终状态
console.log((userPerm & Permission.EDIT) !== 0); // false（编辑已关闭）
console.log((userPerm & Permission.DELETE) !== 0); // true（删除已开启）
核心优势
一个整数即可存储任意多个布尔状态，内存占用极小；状态组合 / 判断 / 切换均为一次位运算，时间复杂度 O (1)，远优于数组 / 对象方式。
五、位运算的核心优势总结
极致性能：CPU 原生底层运算，无类型转换、循环、条件判断等额外开销，比算术运算（+、-、*、/）、逻辑判断更快；
内存高效：可将多个布尔状态 / 标记压缩到一个整数中存储（如 32 位整数可存储 32 个独立状态），大幅降低内存占用，适合海量状态管理；
代码简洁：用简单的运算符替代复杂的逻辑判断 / 算术运算，如异或交换数、按位与判断奇偶，代码更短、可读性更强（熟悉规则后）；
功能独特：部分场景位运算是最优解甚至唯一解，如找唯一出现的数、状态压缩、虚拟 DOM 精准更新（Vue3 PatchFlags），无法用其他方式高效实现。
六、学习建议
先掌握6 种核心位运算的规则和特性（尤其是异或、按位与 / 或），这是所有应用的基础；
熟记高频实用技巧（判断奇偶、取整、交换数等），可直接应用于日常开发，提升代码性能；
练习经典算法实例（找唯一数、缺失数、状态压缩等），理解位运算在算法中的解题思路，应对面试；
结合实际框架 / 源码学习（如 Vue3 PatchFlags、React 位运算优化），理解位运算在大型项目中的实际应用场景。