你想了解 TypeScript 中函数类型相关的语法表示，比如 (...args: any[]) => ...、(...args: any[]) 这类写法的含义，以及其他常见的函数类型表示方式，下面会从核心语法拆解、完整含义解释、常见变体 & 使用场景三方面详细说明，同时结合 TypeScript 类型系统特性讲清设计目的：
一、核心基础：(...args: any[]) 是什么？
(...args: any[]) 是 TypeScript 中函数参数列表的类型表示，结合了「剩余参数语法」和「类型注解」，是描述 **“接收任意数量、任意类型参数”** 的通用写法，逐部分拆解：
...args：剩余参数语法（ES6+ 语法，TS 完全支持），表示 “接收函数传入的所有参数，并将这些参数收集到一个名为 args 的数组中”；
: any[]：类型注解，表示 args 这个数组的类型是「任意类型的数组」（any[] 表示数组元素可以是 string/number/boolean/ 对象等任意类型）；
整体含义：函数可以接收 0 个、1 个或多个参数，参数的类型无任何限制，是描述 “任意参数列表” 的万能写法。
二、(...args: any[]) => R 完整含义：任意参数的函数类型
在 TypeScript 类型系统中，函数类型的核心表示格式是 (参数列表类型) => 返回值类型（这是 TS 定义函数类型的标准语法），因此：
typescript
运行
// 通用任意参数函数类型
(...args: any[]) => R
表示：一个函数类型，它可以接收任意数量、任意类型的参数（由 (...args: any[]) 约束），并且返回值的类型为 R（R 是类型变量，可替换为 string/number/ 自定义类型等具体类型）。
基础示例：固定返回值的任意参数函数类型
typescript
运行
// 定义类型：任意参数，返回值为string
type AnyArgsReturnString = (...args: any[]) => string;

// 合法：符合“任意参数+返回string”约束（无参、单参、多参都可以）
const fn1: AnyArgsReturnString = () => "hello";
const fn2: AnyArgsReturnString = (a: number) => a.toString();
const fn3: AnyArgsReturnString = (x, y, z) => `${x}-${y}-${z}`;

// 非法：返回值不是string，TS编译报错
const fn4: AnyArgsReturnString = (a, b) => a + b;
三、常见变体：(...args: any[]) => any 与 (...args: any[]) => never
基于基础写法衍生的两个高频变体，分别适用于 **“不关心返回值”和“非函数类型兜底”** 场景，也是内置工具类型、自定义条件类型中最常用的：
1. (...args: any[]) => any：任意参数 + 任意返回值的函数类型
含义：函数接收任意参数，返回值类型也无限制（any 表示 “跳过类型检查，任意类型均可”）；
适用场景：仅需要判断 “是否是函数类型”，不关心参数和返回值具体类型（比如基础类型判断、泛型约束）。
typescript
运行
// 示例：判断T是否为函数类型（不关心参数和返回值）
type IsFunction<T> = T extends (...args: any[]) => any ? true : false;

type T1 = IsFunction<() => void>; // true（是函数）
type T2 = IsFunction<(a: number) => string>; // true（是函数）
type T3 = IsFunction<string>; // false（非函数）
2. (...args: any[]) => never：任意参数 + 永不返回的函数类型
补充：never 是 TS 特殊类型，表示 “不存在的类型”，用于函数返回值时表示 “函数永远不会执行完成”（比如抛出错误、无限循环的函数）；
适用场景：极少直接用于描述普通函数，主要在「条件类型兜底」中配合 infer 使用（比如 “如果 T 不是函数类型，就返回 never 表示无有效类型”）。
typescript
运行
// 示例：提取函数返回值，非函数则返回never
type GetReturn<T> = T extends (...args: any[]) => infer R ? R : never;

type R1 = GetReturn<() => string>; // string（正常提取）
type R2 = GetReturn<number>; // never（非函数，兜底返回）
四、其他常见的函数类型表示方式（全覆盖）
除了 “任意参数” 的通用写法，实际开发中还会用到固定参数、可选参数、无参数、带类型约束的剩余参数等函数类型表示，以下是所有常见写法的详细说明，附示例和适用场景：
场景 1：无参数的函数类型 → () => 返回值类型
语法：空参数列表 () + => + 返回值类型；
含义：函数不接收任何参数，仅约束返回值类型；
适用场景：明确函数无入参的场景（比如初始化函数、获取常量的函数）。
typescript
运行
// 类型：无参数，返回值为number
type NoArgsReturnNumber = () => number;

const getNum: NoArgsReturnNumber = () => 100; // 合法
const errFn: NoArgsReturnNumber = (a: number) => a; // 非法：多了参数a
场景 2：固定参数的函数类型 → (p1: T1, p2: T2, ...) => 返回值类型
语法：指定参数名、参数类型（多个参数用逗号分隔），约束参数的数量、类型、顺序；
含义：函数必须接收指定数量、指定类型的参数，且参数顺序要一致，返回值类型固定；
适用场景：明确函数入参的场景（比如业务逻辑函数、工具函数），是最常用的精准函数类型定义。
typescript
运行
// 类型：2个参数（number+string），返回值为boolean
type FixedArgsFn = (a: number, b: string) => boolean;

const fn1: FixedArgsFn = (x, y) => x > 0 && y !== ""; // 合法
const fn2: FixedArgsFn = (x) => x > 0; // 非法：缺少第二个参数
const fn3: FixedArgsFn = (x, y, z) => true; // 非法：多了第三个参数
const fn4: FixedArgsFn = (x, y) => x + y; // 非法：返回值不是boolean
场景 3：包含可选参数的函数类型 → (p1: T1, p2?: T2) => 返回值类型
语法：参数名后加 ? 表示可选参数（可选参数必须放在固定参数之后）；
含义：函数可以接收该参数，也可以不接收，未传入时参数值为 undefined；
适用场景：函数入参非必需的场景（比如带默认值的函数、可选配置的函数）。
typescript
运行
// 类型：1个固定参数（string）+1个可选参数（number），返回值为string
type OptionalArgsFn = (name: string, age?: number) => string;

const fn1: OptionalArgsFn = (n) => `Name: ${n}`; // 合法：不传可选参数
const fn2: OptionalArgsFn = (n, a) => `Name: ${n}, Age: ${a}`; // 合法：传可选参数
const fn3: OptionalArgsFn = (n, a = 18) => `Name: ${n}, Age: ${a}`; // 合法：带默认值
场景 4：带类型约束的剩余参数 → (...args: T[]) => 返回值类型
语法：剩余参数 ...args 搭配具体类型的数组（如 number[]/string[]），而非 any[]；
含义：函数可以接收任意数量的参数，但所有参数的类型必须统一为 T；
适用场景：需要接收多个同类型参数的场景（比如求和、拼接数组的工具函数），比 any[] 更精准，类型安全性更高。
typescript
运行
// 类型：任意数量的number类型参数，返回值为number（比如求和函数）
type SameTypeRestArgsFn = (...args: number[]) => number;

const sum: SameTypeRestArgsFn = (...nums) => nums.reduce((a, b) => a + b, 0); // 合法

sum(1,2,3); // 合法：全是number
sum(1,"2",3); // 非法：包含string类型参数，TS编译报错
场景 5：构造函数类型 → new (...args: 任意参数) => 实例类型
特殊点：构造函数需要加关键字 new，表示 “这是一个用于创建实例的构造函数类型”；
语法：new (参数列表类型) => 实例类型；
含义：通过 new 调用该函数（构造函数），会返回指定类型的实例；
适用场景：描述类的构造函数、泛型中约束 “必须是可实例化的类”，是实现 InstanceType/ConstructorParameters 内置工具类型的核心。
typescript
运行
// 类型：构造函数接收2个参数（string+number），返回Person实例
type PersonConstructor = new (name: string, age: number) => { name: string; age: number };

// 符合构造函数类型的类
class Person {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

// 合法：Person的构造函数符合PersonConstructor类型
const PersonClass: PersonConstructor = Person;
const p = new PersonClass("张三", 20); // p: { name: string; age: number }
五、核心总结（快速查阅）
所有函数类型表示均基于 TS 标准语法 (参数列表类型) => 返回值类型，构造函数额外加 new，核心写法和适用场景整理如下：
语法表示	核心含义	适用场景
(...args: any[])	函数接收任意数量、任意类型参数	仅描述参数列表，配合=>使用
(...args: any[]) => R	任意参数，返回值类型为 R	通用函数类型，自定义工具类型
(...args: any[]) => any	任意参数、任意返回值	仅判断 “是否是函数类型”
(...args: any[]) => never	任意参数，永不返回	条件类型中的非函数兜底
() => T	无参数，返回值类型为 T	明确无入参的函数
(p1:T1, p2:T2) => T	固定数量 / 类型 / 顺序参数，返回 T	精准描述业务函数、工具函数
(p1:T1, p2?:T2) => T	包含可选参数的函数	入参非必需的场景（带默认值）
(...args: T[]) => T	任意数量的同类型参数，返回 T	多同类型入参的工具函数（求和、拼接）
new (...args: T[]) => Instance	构造函数，返回指定实例	描述类的构造函数、实例类型推导
六、关键补充：与 JS 普通函数的区别
很多人会混淆 TS 类型中的 (...args: any[]) => ... 和 JS 代码中的 (...args) => {}，核心区别一句话讲清：
JS 代码中：const fn = (...args) => {} → 实际的函数实现，...args 是运行时收集参数的语法，执行时会真实创建数组；
TS 类型中：type Fn = (...args: any[]) => any → 仅对函数的参数和返回值做类型约束，是编译时的类型描述，不会生成任何运行时代码，仅用于 TS 类型检查。
简单说：一个是运行时的函数实现，一个是编译时的类型定义，这是 TS 类型系统的核心特性（类型擦除，编译后无类型代码）。