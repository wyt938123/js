在 TypeScript 中，keyof 是类型层面的关键字，核心作用是实现类型的键提取与约束，是构建高级类型、实现类型安全的核心基础。它常与 typeof、in、T[K]（索引访问类型）配合使用，四者形成「类型提取 - 类型遍历 - 类型访问」的完整闭环，覆盖从基础类型约束到复杂类型推导的绝大多数场景。以下从核心概念、单独用法、关联关键字配合用法、高级组合场景、内置工具类型应用五方面详细讲解，附完整示例和使用场景。
一、keyof 核心概念与单独基础用法
1. 核心定义
keyof 操作符（称为索引类型查询操作符）作用于对象类型 / 接口 / 类 / 枚举，会返回一个联合类型，该联合类型包含目标类型的所有公共属性名 / 方法名 / 枚举成员名（均为字符串字面量类型）。简单来说：keyof T 能 “提取” 类型 T 的所有键，打包成一个联合类型，让我们可以在类型层面操作这些键。
2. 核心语法
typescript
运行
// 提取类型T的所有键，返回键的联合类型
keyof T
3. 基础使用示例（覆盖常见目标类型）
示例 1：作用于接口（最常用）
typescript
运行
interface User {
  id: number;
  name: string;
  age: number;
  sayHi: () => void; // 方法名也会被提取
}

// keyof User 提取User的所有键，返回联合类型："id" | "name" | "age" | "sayHi"
type UserKeys = keyof User;

// 用法：约束变量只能是User的键
const key1: UserKeys = "id"; // 合法
const key2: UserKeys = "sayHi"; // 合法
const key3: UserKeys = "gender"; // 非法："gender"不是User的键，编译报错
示例 2：作用于类
typescript
运行
class Person {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  run() {}
}

// keyof Person 提取类的公共属性和方法名，返回："name" | "age" | "run"
type PersonKeys = keyof Person;
示例 3：作用于枚举
typescript
运行
enum Direction {
  LEFT = "left",
  RIGHT = "right",
  UP = "up"
}

// keyof Direction 提取枚举的成员名，返回："LEFT" | "RIGHT" | "UP"
type DirectionKeys = keyof Direction;
示例 4：作用于普通对象类型（字面量对象）
typescript
运行
type Product = {
  id: string;
  price: number;
  stock: boolean;
};

// keyof Product 返回："id" | "price" | "stock"
type ProductKeys = keyof Product;
4. 特殊情况：作用于基础类型
keyof 作用于 string/number/boolean 等基础类型时，会提取该类型原型上的所有公共方法名和属性名（实际开发中极少使用，仅作了解）：
typescript
运行
// keyof string 提取String原型的键，如 "length" | "charAt" | "substring" 等
type StringKeys = keyof string;
const sKey: StringKeys = "length"; // 合法
二、核心关联关键字 1：typeof（类型推导）
1. 与 keyof 的核心配合价值
typeof 是值到类型的推导操作符，作用于运行时的变量 / 常量，会推导出该值对应的TypeScript 类型。它与 keyof 是黄金搭档：实际开发中，我们常先定义运行时的常量对象（而非纯类型），再通过 typeof 推导其类型，最后用 keyof 提取该类型的键，实现「从运行时值到类型键的无缝推导」，避免类型与值的重复定义。
2. 核心配合语法
typescript
运行
// 步骤1：定义运行时常量对象
const obj = { a: 1, b: "2" };
// 步骤2：typeof obj 推导obj的类型：{ a: number; b: string }
// 步骤3：keyof typeof obj 提取该类型的键，返回："a" | "b"
type ObjKeys = keyof typeof obj;
3. 实用示例（解决 “类型与值重复定义” 问题）
传统写法：重复定义类型和值，易维护不一致：
typescript
运行
// 定义类型
type Status = { success: 200; fail: 500; error: 400 };
// 定义对应值，需与类型保持一致，修改时要改两处
const status = { success: 200, fail: 500, error: 400 };
keyof + typeof 优化写法：仅定义运行时值，类型自动推导，无重复：
typescript
运行
// 步骤1：仅定义运行时常量对象（as const 让值变为字面量类型，推导更精准）
const status = {
  success: 200,
  fail: 500,
  error: 400
} as const; // 关键：as const 锁定值为字面量，避免推导为 number 泛型

// 步骤2：typeof status 推导类型：{ readonly success: 200; readonly fail: 500; readonly error: 400 }
// 步骤3：keyof typeof status 提取键："success" | "fail" | "error"
type StatusKeys = keyof typeof status;
// 拓展：提取值的联合类型：200 | 500 | 400
type StatusValues = typeof status[StatusKeys];

// 用法：约束变量
const k: StatusKeys = "success"; // 合法
const v: StatusValues = 500; // 合法
✅ 关键补充：as const 是常量断言，让 TypeScript 推导时将对象的属性值视为字面量类型（如 200 而非 number），同时将对象变为只读，提升类型推导的精准度，是 keyof + typeof 配合的常用优化手段。
三、核心关联关键字 2：in（类型遍历）
1. 与 keyof 的核心配合价值
in 是类型层面的遍历操作符，作用于联合类型，会遍历联合类型中的每一个成员，常用于映射类型（TypeScript 高级类型）的定义。它与 keyof 配合的核心场景：用 keyof T 提取类型 T 的所有键（联合类型），再用 in 遍历这些键，为每个键定义新的类型规则，实现基于原类型的类型映射 / 转换。
2. 核心配合语法
typescript
运行
// 映射类型核心语法：遍历keyof T的每一个键K，为每个K定义类型T[K]（或自定义类型）
type MappedType<T> = {
  [K in keyof T]: 自定义类型 | T[K];
};
K in keyof T：遍历 keyof T 联合类型中的每一个键，记为临时类型变量 K；
[K]：动态定义对象的属性名，为遍历到的每个键创建属性；
T[K]：索引访问类型（下文讲解），表示 “类型 T 中键 K 对应的属性类型”。
3. 基础示例：实现只读类型（模拟内置 Readonly<T>）
typescript
运行
// 手动实现内置工具类型Readonly<T>：将原类型的所有属性变为只读
type MyReadonly<T> = {
  readonly [K in keyof T]: T[K]; // 遍历keyof T的每个键，添加readonly修饰符，类型保持原类型T[K]
};

// 测试：原接口
interface User {
  id: number;
  name: string;
}

// 转换为只读类型
type ReadonlyUser = MyReadonly<User>;
// ReadonlyUser 等价于：{ readonly id: number; readonly name: string }

// 用法：属性无法修改，TS编译校验
const user: ReadonlyUser = { id: 1, name: "张三" };
// user.id = 2; // 非法：只读属性不能修改，编译报错
4. 基础示例：实现可选类型（模拟内置 Partial<T>）
typescript
运行
// 手动实现内置工具类型Partial<T>：将原类型的所有属性变为可选
type MyPartial<T> = {
  [K in keyof T]?: T[K]; // 遍历keyof T的每个键，添加?修饰符，类型保持原类型T[K]
};

type PartialUser = MyPartial<User>;
// PartialUser 等价于：{ id?: number; name?: string }

const pUser: PartialUser = { name: "李四" }; // 合法：可选属性可省略
四、核心关联语法 3：T [K]（索引访问类型）
1. 与 keyof/in 的核心配合价值
T[K] 称为索引访问类型，作用是获取类型 T 中键 K 对应的属性类型，是连接 “键” 和 “键对应类型” 的桥梁。它与 keyof + in 是不可分割的三元组：keyof T 提取键、in 遍历键、T[K] 获取遍历过程中每个键对应的原类型，三者结合是实现所有映射类型的基础。
2. 核心语法与基础用法
typescript
运行
// 获取类型T中键K对应的属性类型（K必须是keyof T的子类型）
T[K]
typescript
运行
// 基础示例
interface User {
  id: number;
  name: string;
  age: number;
}

type UserKeys = keyof User; // "id" | "name" | "age"

// 获取单个键的类型
type IdType = User["id"]; // number
type NameType = User["name"]; // string

// 结合联合类型：获取多个键的类型联合
type IdAndNameType = User["id" | "name"]; // number | string
// 等价于 User[UserKeys]（遍历所有键，获取值的联合类型）
type UserValueTypes = User[UserKeys]; // number | string
3. 与 keyof/in 配合的核心示例：实现属性类型转换
将原类型的所有属性类型统一转换为 string 类型，充分体现三者的配合价值：
typescript
运行
// 定义映射类型：将T的所有属性类型转换为string
type AllString<T> = {
  [K in keyof T]: string; // 遍历keyof T的每个键K，属性类型强制设为string（替换原T[K]）
};

interface Product {
  id: number;
  price: number;
  stock: boolean;
}

// 转换后：所有属性类型变为string
type StringProduct = AllString<Product>;
// StringProduct 等价于：{ id: string; price: string; stock: string }
五、keyof + 关联关键字 高级组合场景
场景 1：实现泛型取值函数（类型安全的属性访问）
实现一个通用函数，能安全地获取对象的指定属性值，避免访问不存在的属性，核心依赖 keyof 约束属性名、T[K] 推导返回值类型：
typescript
运行
/**
 * 泛型取值函数：安全获取对象的指定属性
 * @param obj 目标对象
 * @param key 对象的属性名（由keyof T约束，确保存在）
 * @returns 对象中key对应的属性值（类型为T[K]，精准推导）
 */
function getObjValue<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// 测试
const user = { id: 1, name: "张三", age: 20 };
const product = { id: "p001", price: 99.9, stock: true };

// 合法：key是user的有效属性，返回值类型精准推导
const userName = getObjValue(user, "name"); // userName: string
const productPrice = getObjValue(product, "price"); // productPrice: number

// 非法：key不是user的有效属性，编译报错
// const userGender = getObjValue(user, "gender");
✅ 核心亮点：泛型约束 K extends keyof T 确保传入的 key 一定是对象 obj 的有效属性，T[K] 让函数返回值类型与属性类型完全一致，实现100% 类型安全的属性访问。
场景 2：实现内置工具类型 Pick<T, K>（提取指定属性）
手动实现 TypeScript 内置工具类型 Pick<T, K>，用于从类型 T 中提取指定的属性 K，保留原属性类型，核心依赖 keyof T 约束 K 的范围、in 遍历 K、T[K] 保留原类型：
typescript
运行
// 手动实现Pick<T, K>：从T中提取K指定的属性（K必须是keyof T的子类型）
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P]; // 遍历指定的键K，保留原类型T[P]
};

// 测试
interface User {
  id: number;
  name: string;
  age: number;
  email: string;
}

// 从User中提取id和name属性
type UserBase = MyPick<User, "id" | "name">;
// UserBase 等价于：{ id: number; name: string }

const baseUser: UserBase = { id: 1, name: "张三" }; // 合法
场景 3：实现内置工具类型 Record<K, T>（创建键值对类型）
手动实现内置工具类型 Record<K, T>，用于创建一个以 K 为键、T 为统一属性类型的对象类型，核心依赖 keyof 配合泛型约束 K 为合法键类型、in 遍历 K：
typescript
运行
// 手动实现Record<K, T>：K为键的联合类型，所有键的属性类型均为T
// keyof any 是TS内置类型，等价于 string | number | symbol（对象的合法键类型）
type MyRecord<K extends keyof any, T> = {
  [P in K]: T; // 遍历键K，所有属性类型设为T
};

// 测试1：创建以"left"/"right"为键，string为值的类型
type Direction = MyRecord<"left" | "right", string>;
// Direction 等价于：{ left: string; right: string }

// 测试2：创建用户映射（以string为id，User为值）
type UserMap = MyRecord<string, User>;
const userMap: UserMap = {
  "1": { id: 1, name: "张三", age: 20, email: "zhangsan@test.com" },
  "2": { id: 2, name: "李四", age: 21, email: "lisi@test.com" }
};
六、keyof 及关联关键字在内置工具类型中的应用
TypeScript 中绝大多数内置高级工具类型都是基于 keyof + typeof + in + T[K] 实现的，掌握这些底层逻辑，能快速理解高级类型的设计思路，以下是核心内置工具类型的实现简化版：
内置工具类型	功能	基于关联关键字的简化实现
Readonly<T>	将 T 的所有属性设为只读	type Readonly<T> = { readonly [K in keyof T]: T[K] }
Partial<T>	将 T 的所有属性设为可选	type Partial<T> = { [K in keyof T]?: T[K] }
Required<T>	将 T 的所有可选属性设为必选	type Required<T> = { [K in keyof T]-?: T[K] }
Pick<T, K>	从 T 中提取指定属性 K	type Pick<T, K extends keyof T> = { [P in K]: T[P] }
Omit<T, K>	从 T 中排除指定属性 K（TS4.1+）	type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
Record<K, T>	创建以 K 为键、T 为值的对象类型	type Record<K extends keyof any, T> = { [P in K]: T }
Extract<T, U>	从 T 中提取属于 U 的成员	type Extract<T, U> = T extends U ? T : never（配合 keyof 使用）
Exclude<T, U>	从 T 中排除属于 U 的成员	type Exclude<T, U> = T extends U ? never : T（配合 keyof 使用）
七、核心总结
keyof：核心是提取类型的键，返回键的联合类型，作用于对象 / 接口 / 类 / 枚举，是所有键相关类型操作的基础；
typeof：核心是值推导类型，作用于运行时值，与 keyof 配合实现 “从运行时值到类型键” 的推导，解决类型与值重复定义问题，as const 可优化推导精准度；
in：核心是遍历联合类型，作用于 keyof 返回的键联合类型，是映射类型的核心，实现 “逐个处理键”；
T[K]：核心是访问键对应类型，是连接 “键” 和 “值类型” 的桥梁，与前三者配合实现类型的精准映射；
核心闭环：typeof（值→类型）→ keyof（类型→键联合）→ in（遍历键）→ T[K]（访问键对应类型），四者结合是 TypeScript 高级类型、内置工具类型的底层基石；
核心价值：实现类型安全的属性操作、通用的类型映射 / 转换、避免魔法键名，大幅提升代码的可维护性和类型严谨性，是从 TS 基础进阶到高级的必备知识点。
掌握 keyof 及关联关键字的配合使用，就能自主封装自定义工具类型，处理复杂的业务类型推导，真正发挥 TypeScript 类型系统的强大能力。