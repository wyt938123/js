https://juejin.cn/post/6855517117778198542

下面有重要总结

协变和逆变是和赋值有关的

可赋值性 assignable
    ------ 子类型有更多的属性 、、、、使用更加具体 XXXXX




在类型系统中，属性更多的类型是子类型--即更少的更宽泛
「1.类
2.函数变量，参数少跟宽泛
」

在集合论中，属性更少的集合是子集。 -- 即属性更多的更宽泛，区分上面

而一律更具体的可以赋值给跟宽泛的  ---核心


找到父类型子类型就可以了
子类型才可以给父类型赋值

协变--对象赋值
逆变--函数赋值（是fna=fnb）这里不允许具体给宽泛

简单说就是，具有父子关系的多个类型，在通过某种构造关系构造成的新的类型，如果还具有父子关系则是协变的，而关系逆转了（子变父，父变子）就是逆变的


父类型表示的范围更广、包含的内容更多；子类型表示的范围更窄、包含的内容更少。你提到的「字符串索引返回值是父类型（范围更广），数字索引返回值是子类型（范围更窄）」完全正确，并非 “string 父类型表示更少”，而是父类型本身就是「更大的集合」。
用一句话记：父 = 范围大 / 内容多；子 = 范围小 / 内容少。
一、用「集合概念」理解：父类型是超集，子类型是子集
类型的「父子关系」本质就是集合的「超集 / 子集」关系，这是理解范围大小的核心：
父类型：对应超集—— 包含的元素更多、范围更广，能覆盖更多场景；
子类型：对应子集—— 包含的元素更少、范围更窄，是父类型的 “精细化子集”。
举个最直观的例子（延续之前的Animal/Dog），用集合画出来一眼就能看懂：
plaintext
【父类型 Animal】集合：{ 所有有name属性的动物（猫、狗、鸟、猪...）} → 范围大、内容多
        ↓ 子集（子类型）
【子类型 Dog】集合：{ 所有有name+breed属性的狗 } → 范围小、内容少（只是Animal中的一部分）
Dog 是 Animal 的子类型，因为 Dog 的所有实例都属于 Animal，但 Animal 中有大量实例（猫、鸟）不属于 Dog —— 子类型的范围完全被父类型包含，这是父子类型的核心判定标准。











interface User {
  id: number;
  kind: string;
};

function makeCustomer<T extends User>(u: T): T {
  // Error（TS 编译器版本：v4.4.2）
  // Type '{ id: number; kind: string; }' is not assignable to type 'T'.
  // '{ id: number; kind: string; }' is assignable to the constraint of type 'T', 
  // but 'T' could be instantiated with a different subtype of constraint 'User'.
  //{d: u.id kind: 'customer'} 更加宽泛，宽泛不能给具体的T
  return {
    ...u,
    kind: 'customer'as T['kind']
  }
}


https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247495521&idx=1&sn=dd26b5b4f2cd2c78dcbcc9fd15b27df7&scene=21&poc_token=HHQISWmjfe3igXLEP95oN5aWXVP3nbB45liU-P38


https://juejin.cn/post/7095547569777934367



K extends keyof T
K extends ...
泛型约束：限制传入的泛型参数 K 必须是 keyof T 的子类型（即 K 只能是 keyof T 中的一个 / 多个属性名，不能是其他值）。
子类型：对于keyof得到的联合类型 a|b|c  a...属于子类型（集合论）
           T extends string | number  那么T只能是string或者是numner

对于 T extends User 那么必须要多于user的属性才能是子属性 - 类型系统
function makeCustomer<T extends User>(u: T): T {
  // 解构 u 保留所有 T 类型的属性，仅覆盖 kind
  return {
    ...u, // 关键：继承原对象的所有属性（包括 T 扩展的属性）
    kind: 'customer'
  };
}

ts重要内置工具类型还有哪些呢





type[keyof T] 并不是 “展开 type 类型本身”，而是提取 type 这个对象类型的所有属性值类型，并合并为一个联合类型（可以理解为 “把对象类型的「值」展开成联合类型”）。

// 原对象类型
type User = {
  id: number;
  name: string;
  isAdmin: boolean;
};

// 步骤1：keyof User → "id" | "name" | "isAdmin"（属性名联合类型）
// 步骤2：User[keyof User] → User["id"] | User["name"] | User["isAdmin"]
// 步骤3：合并结果 → number | string | boolean
type UserValueTypes = User[keyof User]; 









